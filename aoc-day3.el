(setq file (->> "aoc-input" (f-read) (s-lines))
      field (->> file
		 (mapcar (lambda (x) (s-split "" x t)))
		 (mapcar (lambda (x) (-filter (lambda (y) (not (s-blank? y))) x))))
      width (->> file (car) (length))
      length (->> file length))

;(check 0 2 field)
;(check 0 0 field)
(defun nmlz (x) (if x x "."))
(defun check (i j field)
  (not (and (s-matches? "[0-9.]" (nmlz (nth (- j 1) (nth (+ i 1) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (- j 1) (nth (+ i 0) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (- j 1) (nth (- i 1) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (+ j 0) (nth (+ i 1) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (+ j 0) (nth (- i 1) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (+ j 1) (nth (+ i 1) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (+ j 1) (nth (+ i 0) field))))
	    (s-matches? "[0-9.]" (nmlz (nth (+ j 1) (nth (- i 1) field)))))))

(progn
  (setq i 0 j 0 sum 0 partnumber "" applicable nil)
  (while (<= i length)
    (while (<= j width)
      (if (s-numeric? (nmlz (nth j (nth i field))))
	  (setq partnumber (s-join "" (list partnumber (nth j (nth i field))))
		applicable (or applicable (check i j field)))
	(unless (s-blank? partnumber)
	  (setq sum (if applicable (+ sum (string-to-number partnumber)) sum)
		partnumber ""
		applicable nil)))
      (setq j (1+ j)))
    (setq i (1+ i)
	  j 0))
  (identity (list i j sum partnumber applicable)))
